<?xml version="1.0" encoding="UTF-8"?>

<rootTag>
  <Award>
    <AwardTitle>III: Small: Just in Time Datastructures</AwardTitle>
    <AwardEffectiveDate>07/15/2016</AwardEffectiveDate>
    <AwardExpirationDate>06/30/2019</AwardExpirationDate>
    <AwardAmount>502274</AwardAmount>
    <AwardInstrument>
      <Value>Standard Grant</Value>
    </AwardInstrument>
    <Organization>
      <Code>05020000</Code>
      <Directorate>
        <LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
      </Directorate>
      <Division>
        <LongName>Div Of Information &amp; Intelligent Systems</LongName>
      </Division>
    </Organization>
    <ProgramOfficer>
      <SignBlockName>Nan Zhang</SignBlockName>
    </ProgramOfficer>
    <AbstractNarration>Indexes have always been a critical component of any database. Now that "big data" is a household term, they're more crucial than ever before. Indexes keep data organized, making it faster and easier for you to get at anything from the microblogs in your stream to the money in your bank account. Of course, it's sometimes hard to figure out how to best keep data organized. For example, online social media often needs to handle over a hundred thousand new messages in a single second. That's a lot of data that needs to be organized, and it needs to be organized fast to keep up with the users' needs. The Just-in-Time Data Structures project is exploring ways to make indexes smarter, better able to prioritize their work, and better able to adapt to changing workload patterns.&lt;br/&gt;&lt;br/&gt;Specifically, we're generalizing a class of index data structures called adaptive indexes. In an adaptive index, data is organized as a side-effect of query processing. In a just-in-time data structure, user-defined policies specify how an index is to be transformed in reaction to queries and new data. Like a just-in-time compiler, the index is adaptively optimized for the workload that is currently being presented to it. In addition to laying the foundations for research on just-in-time data structures, we are exploring how to design workload-optimal policies, and how just-in-time data structures can be adapted for incremental view maintenance.</AbstractNarration>
    <MinAmdLetterDate>07/21/2016</MinAmdLetterDate>
    <MaxAmdLetterDate>04/13/2017</MaxAmdLetterDate>
    <ARRAAmount/>
    <AwardID>1617586</AwardID>
    <Investigator>
      <FirstName>Lukasz</FirstName>
      <LastName>Ziarek</LastName>
      <EmailAddress>lziarek@buffalo.edu</EmailAddress>
      <StartDate>07/21/2016</StartDate>
      <EndDate/>
      <RoleCode>Co-Principal Investigator</RoleCode>
    </Investigator>
    <Investigator>
      <FirstName>Oliver</FirstName>
      <LastName>Kennedy</LastName>
      <EmailAddress>okennedy@buffalo.edu</EmailAddress>
      <StartDate>07/21/2016</StartDate>
      <EndDate/>
      <RoleCode>Principal Investigator</RoleCode>
    </Investigator>
    <Institution>
      <Name>SUNY at Buffalo</Name>
      <CityName>Amherst</CityName>
      <ZipCode>142282567</ZipCode>
      <PhoneNumber>7166452634</PhoneNumber>
      <StreetAddress>520 Lee Entrance</StreetAddress>
      <CountryName>United States</CountryName>
      <StateName>New York</StateName>
      <StateCode>NY</StateCode>
    </Institution>
    <ProgramElement>
      <Code>7364</Code>
      <Text>INFO INTEGRATION &amp; INFORMATICS</Text>
    </ProgramElement>
    <ProgramReference>
      <Code>7364</Code>
      <Text>INFO INTEGRATION &amp; INFORMATICS</Text>
    </ProgramReference>
    <ProgramReference>
      <Code>7923</Code>
      <Text>SMALL PROJECT</Text>
    </ProgramReference>
    <ProgramReference>
      <Code>9251</Code>
      <Text>RES EXPER FOR UNDERGRAD-SUPPLT</Text>
    </ProgramReference>
  </Award>
</rootTag>
